# Implement about leader Election



## 名词解释



| 参数        | 解释                                                         |
| ----------- | ------------------------------------------------------------ |
| commitIndex | 已知的最大的已经被提交的日志条目的索引值                     |
| lastApplied | 最后被应用到状态机的日志条目索引值（初始化为 0，持续递增）   |
| nextIndex[] | 对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一） |
| matchIndex[]   | 对于每一个服务器，已经复制给他的日志的最高索引值 |



## Leader选举流程

JRaft 在设计层面将选举的过程拆分为预选举和正式选举两个过程，之所以这样设计是为了避免无效的选举进程递增 term 值，进而造成浪费，同时也会导致正常运行的 Leader 节点执行角色降级。Raft 算法要求当节点接收到 term 值更大的请求时需要递增本地的 term 值，以此实现集群中 term 值的同步。对于 Leader 节点而言，当收到 term 值更大的请求时，该节点会认为集群中有新的 Leader 节点生成，于是需要执行角色降级。这一机制能够保证在出现网络分区等问题时，在网络恢复时能够促使 term 值较小的 Leader 节点退位为 Follower 节点，从而实现让集群达到一个新的平稳状态。然而，如果集群中某个 Follower 节点因为某些原因未能接收到 Leader 节点的主权宣示指令，就会一直尝试发动新一轮的选举革命，进而递增 term 值，导致 Leader 节点执行角色降级，最终影响整个集群的正常运行。

预选举的引入则能够很好的解决此类问题，当一个 Follower 节点尝试发起一轮新的选举革命时，该节点不会立即递增 term 值，而是尝试将 term 值加 1 去试探性的征集选票，只有当集群中过半数的节点同意投票的前提下才会进入正式投票的环节，这样对于无效选举而言一般只会停留在预选举阶段，不会对集群的正常运行造成影响。

预选举的整体执行流程可以概括如下：

1. 校验当前节点是否正在安装快照，如果是则放弃预选举；
2. 校验当前节点是否位于节点配置列表中，如果不是则说明当前节点不是一个有效节点，放弃预选举；
3. 从本地磁盘获取最新的 LogId，包含 logIndex 和 term 值；
4. 初始化预选举选票 Ballot 实例；
5. 遍历向除自己以外的所有连通节点发送 RequestVote RPC 请求，以征集选票，同时给自己投上一票；
6. 如果票数过半，则执行 `NodeImpl#electSelf` 操作进入正式投票环节

### RequestVote 预选举请求处理

发起预选举的节点会以 RPC 的方式向集群中的其它节点发送 RequestVote RPC 请求，以征集选票，各节点会基于本地的运行状态决定是否为其投上自己的一票。需要注意的两点是：

1. 预选举阶段的 RequestVote 请求会设置 `preVote = true`，以标识自己是一个预选举请求，用来与正式投票阶段的 RequestVote 请求请求相区别。
2. 为了避免 term 值无谓的递增，预选举阶段不会真正递增 term 值，而只是将 term 加 1 进行试探性的发起投票。

整体响应预选举 RequestVote 请求的执行流程可以概括为：

1. 如果当前节点处于非活跃状态，则响应错误；
2. 否则，解析候选节点的节点 ID，如果解析出错，则响应错误；
3. 否则，如果当前节点与对应 Leader 节点之间的租约仍然有效，则拒绝投票；
4. 否则，如果候选节点的 term 值相较于当前节点小，则拒绝投票；如果当前节点正好是 Leader 节点，还需要检查候选节点与当前节点之间的复制关系；
5. 否则，获取本地最新的 logIndex 和对应的 term 值，如果候选节点的 term 和 logIndex 值更新，则同意投票，否则拒绝投票。

如果当前节点是 Leader 节点，但是仍然有节点发起预选举进程，则说明当前节点与目标节点之间的复制关系存在问题，需要重新建立复制关系，并启动对应的复制器 Replicator。

### 正式投票流程

正式选举进程的整体执行流程可以概括如下：

1、校验当前节点是否是合法节点，即属于集群节点配置集合中的一员，如果不是则放弃参选；
2、如果当前节点是 FOLLOWER 角色，说明是刚刚从预选举阶段过渡而来，需要停止预选举计时器 electionTimer，避免期间再次发起新的预选举进程；
3、重置本地记录的 leader 节点的 ID；
4、切换节点为 CANDIDATE 角色、递增 term 值，以及更新 votedId 为当前节点 ID；
5、启动正式选举计时器 voteTimer，用于当正式选举超时时，再次发起一轮新的正式选举进程；
6、初始化正式选票 Ballot 实例；
7、获取本地最新的 logIndex 和对应的 term 值；
8、遍历向除自己以外的所有连通节点发送 RequestVote RPC 请求，以征集选票，同时给自己投上一票；
9、更新本地元数据信息，即 term 值和 votedId 值；
10、如果票数过半，则执行 NodeImpl#becomeLeader 操作以切换角色为 LEADER，即竞选成功。

总的来说，正式选举与预选举阶段的执行流程基本相同，不过在正式选举阶段会真正递增 term 值。

响应正式选举 RequestVote 请求的整体执行流程可以概括为：

1、如果当前节点处于非活跃状态，则响应错误；
2、否则，解析候选节点的节点 ID，如果解析出错则响应错误；
3、否则，如果候选节点的 term 值小于当前节点，则拒绝投票；
4、否则，如果候选节点的 term 值大于当前节点，则需要执行 stepdown；
5、如果候选节点的 term 值更新，或者 term 值相同但是对应的 logIndex 不小于当前节点，且当前节点未投票给其它节点，则同意投票，同时更新本地元数据信息；
6、否则，拒绝投票。

关于步骤 4，此时处理 RequestVote RPC 请求的节点角色仍然是 FOLLOWER，所以除了重置本地状态和再次启动预选举计时器之外，一个重要的工作就是更新当前节点的 term 值，以保证与当前集群已知的最大 term 值看齐。

### 成为Leader

整体的执行流程可以概括为：

1、校验当前节点角色是否为 CANDIDATE，LEADER 角色的前置角色必须是 CANDIDATE；
2、停止正式选举计时器 voteTimer；
3、切换节点角色为 LEADER；
4、建立到除自己以外的所有节点之间的复制关系，包括 Follower 和 Learner；
5、重置选票箱 BallotBox；
6、将当前集群的节点配置信息记录到日志中；
7、启动 stepdown 计时器 stepDownTimer。


## StateMachine and FsmCaller

Raft 通过调用 FSMCaller 中声明的方法实现将内部运行状态透传给业务，而 FSMCaller 在本地则基于 Disruptor 消息队列以事件的形式缓存这些内部状态，并通过异步的方式回调 StateMachine 接口声明的相应方法，这就是 FSMCaller 整体的运行逻辑.

`FSMCallerImpl#runApplyTask` 方法对 Disruptor 消息队列中缓存的状态机事件进行处理。该方法本质上是一个事件分发器，基于具体的状态机事件类型调用对应的 `do*` 方法实现对事件的处理操作

 FSMCaller 和 BallotBox 对象持有的 ClosureQueue 实例是同一个。BallotBox 负责往 ClosureQueue 中写数据，而 FSMCaller 则负责从 ClosureQueue 中读数据。